ğŸ”„ Update Instruction: Abstract Node Visualization + Connector Logic
1ï¸âƒ£ Dual-Layer Node Model (Core Change)

Each node now has two synchronized representations:

A. Abstract (Visual) Layer â€” default

No code shown

Shows:

Node title

Input ports

Output ports

Status (idle / running / error)

Interactable via drag, connect, run

B. Code Layer â€” optional

Full Python code editor

Editable by user

Always reflects the abstract layerâ€™s contract

ğŸ” Toggling between layers should be instant and non-destructive.

2ï¸âƒ£ Node Contract (This Is the Heart)

Every node must explicitly define a contract:

NodeContract {
  inputs: Array<{
    name: string
    type?: string
  }>
  outputs: Array<{
    name: string
    type?: string
  }>
}


This contract is the only thing the canvas and connectors care about.

The code must respect this contract â€” not the other way around.

3ï¸âƒ£ Visual Node Layout (Abstract View)
Structure
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Node Name           â”‚
â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚  Inputs              â”‚
â”‚  â€¢ df                â”‚â—€â”€â”€ connector
â”‚  â€¢ labels            â”‚â—€â”€â”€ connector
â”‚                      â”‚
â”‚  Outputs             â”‚
â”‚  â€¢ model             â”‚â”€â”€â–¶ connector
â”‚  â€¢ metrics           â”‚â”€â”€â–¶ connector
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

UI rules

Inputs always on left

Outputs always on right

Ports are always visible

Code is never shown by default

This gives Scratch-level clarity with ML-grade power.

4ï¸âƒ£ Connector Logic (Updated, Precise Behavior)
A connector represents:

â€œBind output X from node A to input Y of node Bâ€

Connector rules:

Output â†’ Input only

Names must match declared contracts

One input = one source (no ambiguity)

One output â†’ many inputs allowed

Internally store connectors as:
{
  fromNodeId,
  fromOutput,
  toNodeId,
  toInput
}

5ï¸âƒ£ Runtime Execution Mapping (Very Important)

When executing a node:

Collect all incoming connectors

Build input object:

{
  inputName: valueFromUpstream
}


Inject inputs into execution scope

Execute node code

Extract declared outputs only

Store outputs in graph state

âš ï¸ The node code cannot access undeclared inputs.

This enforces discipline and predictability.

6ï¸âƒ£ Keeping Code & Visual Layer in Sync
Output declaration

User must declare outputs via UI:

â€œAdd outputâ€

Name it

(Optional) describe it

Code must assign to that name.

If not:

Node fails validation

Visual error shown

Example:
Declared output: model

Required in code:

model = train(...)

Input declaration

Inputs are:

Declared visually

Bound via connectors

Available as variables in code

No connector â†’ input is undefined â†’ execution error

7ï¸âƒ£ Code Visibility Rules (Strict)

Canvas view never shows code

Code is accessed by:

double click

side panel

toggle button

This keeps the system visual-first, not code-first.

8ï¸âƒ£ Visual Feedback (Crucial UX)

Each node shows:

Green dot â†’ executed successfully

Yellow â†’ waiting for inputs

Red â†’ execution error

Each port:

Grey â†’ unconnected

Blue â†’ connected

Red â†’ incompatible / missing

Edges:

Solid â†’ valid

Dashed â†’ inactive

Red â†’ broken

This replaces reading logs for most issues.

9ï¸âƒ£ Node Creation Paths (Updated)

Nodes can be created from:

Dragging a function block

Importing a notebook cell

Creating an empty code node

All three result in:

Contract generated

Abstract view shown

Code hidden by default

10ï¸âƒ£ Non-Negotiable Design Principle

The graph is the source of truth.
Code is an implementation detail.

This is the shift youâ€™re making â€” and itâ€™s the right one.